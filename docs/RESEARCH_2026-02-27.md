# Исследование проекта LSwitch — полный отчёт

**Дата:** 27 февраля 2026  
**Автор:** Вася (opus-agent)  
**Версия проекта:** LSwitch 2.0

---

## Часть 1: Полное исследование логики работы программы

---

### 1. Конвертация текста

#### 1.1. Общая архитектура

Конвертация управляется классом `ConversionEngine` (`lswitch/core/conversion_engine.py`). У него два основных метода:

- **`choose_mode(context, selection_valid)`** — выбирает режим конвертации
- **`convert(context, selection_valid)`** — выполняет конвертацию

#### 1.2. Алгоритм выбора режима (`choose_mode`)

Приоритеты (от высшего к низшему):

| Приоритет | Условие | Режим | Логика |
|-----------|---------|-------|--------|
| 1 | `context.backspace_hold_active` | selection | Удержание Backspace — явный жест |
| 2 | `context.chars_in_buffer > 0` | retype | Есть набранные символы — **всегда побеждает** |
| 3 | `selection_valid == True` | selection | Пустой буфер + новое выделение |
| 4 | fallback | retype | RetypeMode пропустит (skip gracefully) |

**Ключевой момент:** если пользователь набрал текст (`chars_in_buffer > 0`), ВСЕГДА используется retype, даже если есть выделение. Selection mode активируется только при пустом буфере.

#### 1.3. RetypeMode (`lswitch/core/modes.py`)

**Принцип:** удалить набранные символы → переключить раскладку → воспроизвести те же нажатия в новой раскладке.

**Пошаговый алгоритм:**

```
1. Проверить chars_in_buffer > 0 — если 0, skip (return False)
2. Сохранить копию event_buffer
3. Отправить N backspace через VirtualKeyboard.tap_key(KEY_BACKSPACE, n_chars)
4. Переключить раскладку через xkb.switch_layout()
5. Пауза 50мс (чтобы приложение успело обработать backspace)
6. Воспроизвести сохранённые события через virtual_kb.replay_events(saved_events)
```

**Важная деталь v2:** в v1 был баг — безусловный Shift release в finally-блоке вызывал XKB Shift+Shift toggle, что приводило к дублированию переключения. В v2 Shift release отправляется только если в буфере событий реально были Shift press.

**Поддержка Shift (uppercase):** каждое событие хранит флаг `shifted` (был ли Shift зажат). При replay, если `shifted=True`, VirtualKeyboard оборачивает нажатие в Shift press/release.

#### 1.4. SelectionMode (`lswitch/core/modes.py`)

**Принцип:** прочитать PRIMARY selection → определить язык → конвертировать текст → вставить обратно.

**Пошаговый алгоритм:**

```
1. Прочитать выделение: self.selection.get_selection()
2. Определить язык исходного текста: detect_language(sel.text) — 'en' или 'ru'
3. Определить направление конвертации: en→ru или ru→en
4. Конвертировать текст: convert_text(sel.text, direction)
5. Заменить выделение: self.selection.replace_selection(converted)
6. Переключить раскладку на целевую: xkb.switch_layout(target=target_layout)
```

**`replace_selection`** работает так:
```
1. Сохранить CLIPBOARD: old_clip = get_clipboard("clipboard")
2. Записать конвертированный текст в CLIPBOARD: set_clipboard(new_text, "clipboard")
3. Имитировать Ctrl+V через xdotool
4. Восстановить CLIPBOARD: set_clipboard(old_clip, "clipboard")
```

#### 1.5. Текстовая конвертация (`lswitch/core/text_converter.py`)

Посимвольная замена по таблице `EN_TO_RU` / `RU_TO_EN` из `lswitch/intelligence/maps.py`. Сохраняет регистр:

```python
for ch in text:
    lower = ch.lower()
    converted = table.get(lower)
    if converted is None:
        result.append(ch)  # символ не в таблице — оставить как есть
    else:
        result.append(converted.upper() if ch.isupper() else converted)
```

Определение языка (`detect_language`): если в тексте есть хотя бы один кириллический символ (`\u0400`–`\u04ff`), это `ru`, иначе `en`.

---

### 2. Сочетания клавиш

#### 2.1. Shift+Shift (двойной Shift)

**Основной триггер конвертации.** Измеряется как время между ПЕРВЫМ release и ВТОРЫМ release (не press→release).

**Механизм (StateManager.on_shift_up):**

```python
delta = now - self.context.last_shift_time
if last_shift_time > 0 and delta < double_click_timeout:   # default 0.3s
    # Двойной Shift обнаружен!
    self._transition("shift_up_double")  # → State.CONVERTING
    return True
else:
    self.context.last_shift_time = now  # запомнить первый release
    return False
```

**Обработка в `_on_key_release`:**
```python
is_double = self.state_manager.on_shift_up()
if is_double:
    self._do_conversion()
```

#### 2.2. Backspace Hold (удержание Backspace)

При авто-повторе Backspace (value=2 от evdev):
```python
ctx.backspace_repeats += 1
if ctx.event_buffer:
    ctx.event_buffer.pop()     # удалить последнее событие из буфера
if ctx.chars_in_buffer > 0:
    ctx.chars_in_buffer -= 1   # уменьшить счётчик
if ctx.backspace_repeats >= 3:
    self.state_manager.on_backspace_hold()  # → State.BACKSPACE_HOLD
```

Из состояния `BACKSPACE_HOLD` доступен переход `shift_up_double → CONVERTING`, что активирует selection mode (через `choose_mode`: `backspace_hold_active → "selection"`).

#### 2.3. Navigation Keys

Клавиши `стрелки`, `Home`, `End`, `PgUp`, `PgDn`, `Tab` (коды 103, 108, 105, 106, 102, 107, 104, 109, 15):
- Сбрасывают `_last_auto_marker`
- Сбрасывают `_selection_valid`
- Очищают `_last_retype_events` (sticky buffer)
- Переводят автомат в `IDLE` через `state_manager.on_navigation()`

#### 2.4. Enter

Аналогично navigation: полный сброс состояния.

#### 2.5. Space

Если включена авто-конвертация (`auto_switch`), при пробеле вызывается `_try_auto_conversion_at_space()`. Если авто-конвертация не сработала, пробел добавляется в буфер как обычный символ.

#### 2.6. MODIFIER_KEYS — фильтрация

Модификаторы **полностью игнорируются** при key_press:

```python
elif data.code in MODIFIER_KEYS:
    pass  # modifiers don't produce text — ignore entirely
```

**Состав MODIFIER_KEYS:**
- `KEY_LEFTCTRL (29)`, `KEY_RIGHTCTRL (97)`
- `KEY_LEFTALT (56)`, `KEY_RIGHTALT (100)`
- `KEY_LEFTMETA (125)`, `KEY_RIGHTMETA (126)`
- `KEY_CAPSLOCK (58)`
- `KEY_INSERT (110)`, `KEY_DELETE (111)`
- `KEY_SYSRQ/PrintScreen (99)`, `KEY_PAUSE (119)`
- `F1–F12 (59–68, 87–88)`

Они не добавляются в `event_buffer`, не увеличивают `chars_in_buffer`, не вызывают transition в StateManager.

---

### 3. Буферы

#### 3.1. event_buffer (`StateContext.event_buffer`)

**Тип:** `list` (список `KeyEventData` объектов)  
**Хранит:** все нажатия клавиш (KEY_PRESS, value=1), кроме Shift, модификаторов и Backspace.

Каждый элемент — `KeyEventData`:
```python
@dataclass
class KeyEventData:
    code: int               # evdev keycode
    value: int              # 0=release, 1=press, 2=repeat
    device_name: str = ""
    shifted: bool = False   # True если Shift был зажат
```

**Добавление:** при обычном key_press:
```python
data.shifted = self.state_manager.context.shift_pressed
self.state_manager.context.event_buffer.append(data)
```

**Удаление:**
- Backspace press: `ctx.event_buffer.pop()` (один элемент)
- Backspace repeat: `ctx.event_buffer.pop()` (один на каждый repeat)
- `context.reset()`: полная очистка

#### 3.2. chars_in_buffer (`StateContext.chars_in_buffer`)

**Тип:** `int`  
**Назначение:** счётчик символов в буфере. Может расходиться с `len(event_buffer)` теоретически, но на практике синхронизирован.

- `+1` при обычном key_press (не Shift, не модификатор, не Backspace)
- `-1` при Backspace release (если > 0)
- `-1` при Backspace repeat (если > 0)
- `= 0` при `context.reset()`

**Используется для:**
- `choose_mode()`: chars_in_buffer > 0 → retype
- `RetypeMode.execute()`: skip если chars_in_buffer ≤ 0
- Auto-conversion: skip если chars_in_buffer == 0

#### 3.3. _last_retype_events (sticky buffer)

**Тип:** `list` (в `LSwitchApp`)  
**Назначение:** позволяет повторный Shift+Shift работать после конвертации.

**Логика:**
```
1. Пользователь набирает "руддщ" → event_buffer = [...], chars_in_buffer = 5
2. Shift+Shift → RetypeMode → event_buffer очищается reset()
3. НО: перед reset(), saved_events сохраняются в _last_retype_events
4. Повторный Shift+Shift → chars_in_buffer == 0 → проверяем _last_retype_events
5. Если не пуст → восстанавливаем буфер из _last_retype_events
6. Конвертация выполняется повторно (обратно)
```

**Сброс _last_retype_events:**
- При любом key_press обычного символа: `self._last_retype_events = []`
- При Backspace: `self._last_retype_events = []`
- При Space: `self._last_retype_events = []`
- При navigation/Enter: `self._last_retype_events = []`
- При mouse_click: `self._last_retype_events = []`
- После SelectionMode конвертации: `self._last_retype_events = []`

**Сохраняется только** после успешного RetypeMode (не SelectionMode).

#### 3.4. PRIMARY selection (X11)

**Чтение:** `xclip -o -selection primary` (через `SubprocessSystemAdapter`)  
**Запись:** только через `replace_selection()` — записывает в CLIPBOARD (не PRIMARY) и Ctrl+V  
**Owner ID:** через `Xlib.display.Display().get_selection_owner(Xatom.PRIMARY).id`

**Взаимодействие буферов:**

```
event_buffer + chars_in_buffer → retype mode (прямая конвертация буфера)
PRIMARY selection              → selection mode (конвертация выделенного текста)
_last_retype_events            → повторный retype (sticky конвертация)
```

Буферы **не взаимодействуют** друг с другом напрямую. `choose_mode()` выбирает один из двух путей.

---

### 4. Автомат состояний

#### 4.1. Состояния (State)

```python
class State(Enum):
    IDLE = auto()           # Ожидание ввода
    TYPING = auto()         # Пользователь печатает
    SHIFT_PRESSED = auto()  # Shift нажат (ожидание второго)
    CONVERTING = auto()     # Выполняется конвертация
    BACKSPACE_HOLD = auto() # Удержание Backspace
```

#### 4.2. Таблица переходов (transitions.py)

```
IDLE:
  key_press      → TYPING
  shift_down     → SHIFT_PRESSED     (SelectionMode из IDLE)

TYPING:
  shift_down     → SHIFT_PRESSED
  backspace_hold → BACKSPACE_HOLD
  navigation     → IDLE
  mouse_click    → IDLE
  enter          → IDLE

SHIFT_PRESSED:
  shift_up_single  → TYPING           (один Shift — вернулись к набору)
  shift_up_double  → CONVERTING       (двойной Shift — конвертация!)
  key_press        → TYPING           (нажали другую клавишу — отмена)

BACKSPACE_HOLD:
  key_press        → TYPING
  shift_up_double  → CONVERTING       (двойной Shift после удержания BS)
  navigation       → IDLE
  mouse_click      → IDLE

CONVERTING:
  complete  → IDLE
  cancelled → IDLE
```

#### 4.3. StateContext

```python
@dataclass
class StateContext:
    state: State = State.IDLE
    text_buffer: list[str]     # не используется в текущем коде
    event_buffer: list         # основной буфер нажатий
    chars_in_buffer: int = 0   # счётчик символов
    last_shift_time: float     # время последнего Shift release
    backspace_hold_at: float   # время начала удержания BS
    shift_pressed: bool        # Shift сейчас зажат?
    backspace_repeats: int     # счётчик авто-повторов BS
    backspace_hold_active: bool # BS hold активен?
    current_layout: str = "en" # не используется (раскладка из XKB)
```

#### 4.4. Диаграмма переходов

```
                          key_press
              ┌──────────────────────────────────┐
              │                                  │
              ▼          shift_down               │
           ┌──────┐  ──────────────► ┌───────────────┐
           │ IDLE │                  │ SHIFT_PRESSED │
           └──────┘  ◄────────────── └───────────────┘
              ▲      shift_up_single       │
              │                            │ shift_up_double
              │      key_press             ▼
              │  ┌──────────► ┌────────────────┐
              │  │            │  CONVERTING    │
              │  │            └────────────────┘
              │  │                  │ complete/cancelled
     nav/mouse│  │                 │
     click    │  │                 │
              │  │                 ▼
           ┌──────┐  ◄────────── IDLE
           │TYPING│
           └──────┘
              │
              │ backspace_hold (3+ repeats)
              ▼
           ┌───────────────┐
           │ BACKSPACE_HOLD│──── shift_up_double ──► CONVERTING
           └───────────────┘
```

---

### 5. Event System

#### 5.1. EventBus (`lswitch/core/event_bus.py`)

Лёгкий синхронный pub/sub:

```python
class EventBus:
    subscribe(event_type, handler)   # подписка
    unsubscribe(event_type, handler) # отписка
    publish(event)                   # вызвать всех подписчиков синхронно
```

Все handlers вызываются **синхронно** в том же потоке. Исключения ловятся и логируются.

#### 5.2. EventType (`lswitch/core/events.py`)

```python
class EventType(Enum):
    KEY_PRESS           # Нажатие клавиши
    KEY_RELEASE         # Отпускание клавиши
    KEY_REPEAT          # Авто-повтор (зажатая клавиша)
    DOUBLE_SHIFT        # Двойной Shift (не используется для dispatch, обрабатывается в on_shift_up)
    BACKSPACE_HOLD      # Удержание Backspace
    MOUSE_CLICK         # Клик мышью
    CONVERSION_START    # Начало конвертации
    CONVERSION_COMPLETE # Конвертация завершена
    CONVERSION_CANCELLED # Конвертация отменена
    LAYOUT_CHANGED      # Раскладка изменилась
    CONFIG_CHANGED      # Конфигурация изменена
    APP_QUIT            # Завершение приложения
```

#### 5.3. EventManager (`lswitch/core/event_manager.py`)

**Принимает** сырые evdev события → **классифицирует** → **публикует** типизированные события в EventBus.

```
evdev event (type=EV_KEY) → EventManager.handle_raw_event()
    │
    ├── code ∈ MOUSE_BUTTONS + value==1 → publish(MOUSE_CLICK)
    ├── value == 1 (press)              → publish(KEY_PRESS)
    ├── value == 0 (release)            → publish(KEY_RELEASE)
    └── value == 2 (repeat)             → publish(KEY_REPEAT)
```

#### 5.4. Подписки в app.py (`_wire_event_bus`)

```python
EventType.KEY_PRESS   → _on_key_press
EventType.KEY_RELEASE → _on_key_release
EventType.KEY_REPEAT  → _on_key_repeat
EventType.MOUSE_CLICK → _on_mouse_click
```

#### 5.5. Цепочка обработки evdev события

```
evdev device → DeviceManager.get_events() → (device, event)
    → EventManager.handle_raw_event(event, device.name)
        → EventBus.publish(Event(KEY_PRESS/KEY_RELEASE/KEY_REPEAT/MOUSE_CLICK, data, ts))
            → LSwitchApp._on_key_press / _on_key_release / _on_key_repeat / _on_mouse_click
                → StateManager transitions
                    → ConversionEngine.convert() (при CONVERTING)
                        → RetypeMode / SelectionMode
```

---

### 6. Автоматическое переключение

#### 6.1. AutoDetector (`lswitch/intelligence/auto_detector.py`)

Решает, нужно ли конвертировать слово автоматически при пробеле.

**Цепочка приоритетов:**

```
1. Слово уже правильное в текущей раскладке (словарь) → НЕ конвертировать
2. UserDictionary.is_protected() → НЕ конвертировать (временная защита)
3. UserDictionary.get_weight() ≤ -min_weight → НЕ конвертировать (пользователь отменял)
4. Конвертированное слово найдено в словаре целевой раскладки → КОНВЕРТИРОВАТЬ
5. N-gram score целевого языка значительно лучше → КОНВЕРТИРОВАТЬ
6. N-gram score исходного = 0 и длина слова ≥ 4 → КОНВЕРТИРОВАТЬ
7. Иначе → НЕ конвертировать
```

#### 6.2. DictionaryService (`lswitch/intelligence/dictionary_service.py`)

Лениво загружает множества слов `RUSSIAN_WORDS` и `ENGLISH_WORDS`.

```python
should_convert("ghbdtn", "en"):
    1. "ghbdtn" в ENGLISH_WORDS? → Нет
    2. convert("ghbdtn") → "привет". "привет" в RUSSIAN_WORDS? → Да!
    → (True, "converted to Russian word 'привет'")
```

#### 6.3. NgramAnalyzer (`lswitch/intelligence/ngram_analyzer.py`)

Биграмный/триграмный анализ. Score = среднее значение частот биграмм + триграмм*3.

#### 6.4. UserDictionary (`lswitch/intelligence/user_dictionary.py`)

Самообучающийся словарь:

- **add_confirmation(word, lang):** вес +1 (слово конвертировалось правильно)
- **add_correction(word, lang):** вес -1 + временная защита (5 секунд)
- **is_protected(word, lang):** временная защита от авто-конвертации
- **get_weight(word, lang):** текущий вес слова

Хранение: `~/.config/lswitch/user_dict.json`

#### 6.5. Авто-конвертация при пробеле (`_try_auto_conversion_at_space`)

**Алгоритм:**

```
1. Проверить chars_in_buffer > 0
2. Проверить порог (auto_switch_threshold)
3. Получить текущую раскладку через XKB
4. Извлечь последнее слово из event_buffer (_extract_last_word_events)
5. Спросить AutoDetector.should_convert(word, current_lang)
6. Если предыдущая авто-конвертация была принята → user_dict +1
7. Если should → выполнить _do_auto_conversion_at_space()
```

**`_do_auto_conversion_at_space`:**
```
1. Удалить word_len+1 символов (слово + пробел, который уже попал в приложение)
2. Переключить раскладку
3. Воспроизвести оригинальные keycodes (в новой раскладке = конвертированный текст)
4. Добавить пробел
5. Сохранить _last_auto_marker для возможной отмены
6. Сбросить контекст (reset + IDLE)
```

#### 6.6. `_last_auto_marker`

Маркер последней авто-конвертации:
```python
{'word': 'ghbdtn', 'direction': 'en_to_ru', 'lang': 'en', 'time': 1234567890.0}
```

**Используется для:**
- Если после авто-конвертации пользователь сразу нажал Shift+Shift → это ОТМЕНА → `user_dict.add_correction()`
- Если продолжил печатать до следующего пробела → авто-конвертация принята → `user_dict.add_confirmation()`

#### 6.7. `_extract_last_word_events`

Сканирует `event_buffer` с конца до пробела или не-буквенного символа. Использует реальное XKB mapping для определения символов (важно для RU раскладки, где `,` → `б`, `.` → `ю`).

---

### 7. Флаг `_selection_valid`

#### 7.1. Назначение

Указывает, есть ли **свежее** выделение текста, которое можно использовать для SelectionMode.

#### 7.2. Установка в True

Единственное место:
```python
# _check_selection_changed() в app.py
if owner_changed or text_changed:
    self._selection_valid = True
```

`_check_selection_changed()` вызывается в `_do_conversion()` **перед** конвертацией.

#### 7.3. Сброс в False

Многие места:
- `_on_key_press`: обычный символ, Backspace, Space
- `_on_key_release`: navigation, Enter
- `_on_mouse_click`: при любом клике мыши
- `_do_conversion` (finally): после конвертации

**Смысл:** после клика мыши (сброс выделения) или набора нового текста, selection_valid сбрасывается. Свежее выделение определяется в момент Shift+Shift через `_check_selection_changed()`.

#### 7.4. Как используется

```python
# В _do_conversion:
self._check_selection_changed()  # может установить _selection_valid = True

success = self.conversion_engine.convert(
    context, selection_valid=self._selection_valid
)

# choose_mode проверяет:
if context.chars_in_buffer > 0:  return "retype"    # приоритет!
if selection_valid:              return "selection"   
```

---

### 8. _on_mouse_click

#### 8.1. Полный код

```python
def _on_mouse_click(self, event):
    self._last_auto_marker = None       # сброс маркера авто-конвертации
    self._selection_valid = False        # сброс флага выделения
    self._last_retype_events = []       # сброс sticky buffer
    # Snapshot current PRIMARY
    if self.selection is not None:
        try:
            info = self.selection.get_selection()
            self._prev_sel_text = info.text
            self._prev_sel_owner_id = info.owner_id
        except Exception:
            pass
    self.state_manager.on_mouse_click()  # state → IDLE, context.reset()
```

#### 8.2. Что происходит

1. **Сброс маркеров** — авто-конвертация, selection_valid, sticky buffer
2. **Снапшот PRIMARY** — запоминает текущее содержимое PRIMARY selection и owner_id
3. **Сброс автомата** — state → IDLE, все буферы чистятся

#### 8.3. Зачем снапшот PRIMARY

Чтобы `_check_selection_changed()` при следующем Shift+Shift не считал старое выделение за "новое". Без снапшота: если PRIMARY содержит "hello" и пользователь кликает в другом окне, а потом сразу Shift+Shift — `_check_selection_changed` увидел бы "hello" из PRIMARY и попытался бы конвертировать.

**Логика:** при клике запоминаем, что сейчас в PRIMARY. При Shift+Shift проверяем: изменилось ли PRIMARY с момента последнего клика? Если да → `_selection_valid = True`. Если нет → пользователь просто кликнул без нового выделения.

---

### 9. Практические примеры

#### Пример 1: Пользователь набирает "руддщ", нажимает Shift+Shift

**Раскладка:** EN (пользователь забыл переключить)  
**Физические нажатия:** r-u-l-l-o → `hello` в EN, но пользователь хотел RU  

Нет, подожди. "Руддщ" — это **кириллица**. Значит, пользователь набрал на EN раскладке буквы `h-e-l-l-o` вместо переключения на RU, и получилось "руддщ"? Нет. 

Давайте точнее: пользователь на **EN** раскладке набирает клавиши `h-e-l-l-o`, и в текстовом поле появляется `hello`. Он хотел `привет`. Он нажимает Shift+Shift.

Или: пользователь на **EN** раскладке набирает клавиши, которые в RU дают "привет": `g-h-b-d-t-n` → в текстовом поле `ghbdtn`. Нажимает Shift+Shift.

Пошаговый сценарий для "ghbdtn" → "привет":

```
Шаг  Событие                        Состояние      event_buffer    chars
1    Key press: g (code=34)         IDLE→TYPING    [g]             1
2    Key press: h (code=35)         TYPING         [g,h]           2
3    Key press: b (code=48)         TYPING         [g,h,b]         3
4    Key press: d (code=32)         TYPING         [g,h,b,d]       4
5    Key press: t (code=20)         TYPING         [g,h,b,d,t]     5
6    Key press: n (code=49)         TYPING         [g,h,b,d,t,n]   6
7    Shift press (code=42)          TYPING→SHIFT_P [g,h,b,d,t,n]   6
8    Shift release (code=42)        SHIFT_P→TYPING last_shift_time=T₁
9    Shift press (code=54)          TYPING→SHIFT_P
10   Shift release (code=54)        delta < 0.3s → SHIFT_P→CONVERTING
                                    → _do_conversion()
```

**_do_conversion:**
```
1. State == CONVERTING ✓
2. _check_selection_changed() → нет нового выделения → _selection_valid = False
3. saved_events = [g,h,b,d,t,n], saved_count = 6
4. _last_retype_events пуст → не восстанавливаем
5. conversion_engine.convert(context, selection_valid=False)
6. choose_mode: chars_in_buffer=6 > 0 → "retype"
```

**RetypeMode.execute:**
```
1. chars_in_buffer = 6 ✓
2. Отправить 6 backspace → "ghbdtn" удаляется из текстового поля
3. switch_layout() → EN → RU (через Cinnamon D-Bus или XkbLockGroup)
4. Пауза 50мс
5. replay_events([g,h,b,d,t,n]) → нажатия g,h,b,d,t,n теперь в RU раскладке
   g → п, h → р, b → и, d → в, t → е, n → т → "привет"
```

**Результат:** "ghbdtn" заменено на "привет", раскладка переключена на RU.

**After:** `_last_retype_events = [g,h,b,d,t,n]`, context.reset(), state → IDLE.

#### Пример 2: Пользователь выделяет текст, нажимает Shift+Shift

**Предусловие:** пользователь выделил мышью слово "ghbdtn" в текстовом поле.

```
Шаг  Событие                        Состояние
1    Mouse drag (выделение)          Не отслеживается (нет click event при drag)
                                     PRIMARY = "ghbdtn", owner изменился
2    Shift press                     IDLE→SHIFT_PRESSED
     (chars_in_buffer == 0, event_buffer пуст)
3    Shift release                   last_shift_time = T₁
4    Shift press                     (уже в SHIFT_PRESSED)
5    Shift release                   delta < 0.3s → SHIFT_P→CONVERTING
                                     → _do_conversion()
```

**_do_conversion:**
```
1. State == CONVERTING ✓
2. _check_selection_changed() → PRIMARY = "ghbdtn", owner изменился
   → _selection_valid = True
3. saved_count = 0, _last_retype_events пуст
4. conversion_engine.convert(context, selection_valid=True)
5. choose_mode: chars_in_buffer=0, selection_valid=True → "selection"
```

**SelectionMode.execute:**
```
1. get_selection() → text="ghbdtn"
2. detect_language("ghbdtn") → "en" (нет кириллицы)
3. direction = "en_to_ru"
4. convert_text("ghbdtn", "en_to_ru") → "привет"
5. replace_selection("привет"):
   a. Сохранить CLIPBOARD
   b. CLIPBOARD = "привет"
   c. xdotool Ctrl+V → вставляет "привет" вместо выделения
   d. Восстановить CLIPBOARD
6. switch_layout → RU
```

#### Пример 3: Повторный Shift+Shift (sticky buffer)

```
Шаг  Событие                        Прим.
1    Набрал "ghbdtn"                 event_buffer = [g,h,b,d,t,n], chars=6
2    Shift+Shift                     → retype → "привет"
                                     _last_retype_events = [g,h,b,d,t,n]
                                     context.reset() → event_buffer=[], chars=0
3    Shift+Shift (сразу, без нового ввода)
     → _do_conversion()
     saved_count = 0, _last_retype_events не пуст!
     → восстановить event_buffer из _last_retype_events
     → chars_in_buffer = 6
     → choose_mode → "retype"
     → RetypeMode: удалить 6 символов, switch_layout (RU→EN), replay
     → "привет" обратно в "ghbdtn"
     → _last_retype_events = [g,h,b,d,t,n] (снова сохранён)
```

**Результат:** каждый повторный Shift+Shift чередует "ghbdtn" ↔ "привет".

#### Пример 4: Авто-конвертация при пробеле

**Предусловие:** раскладка EN, `auto_switch = true`.

```
Шаг  Событие                        Прим.
1    Набрал "ghbdtn"                 event_buffer = [g,h,b,d,t,n], chars=6
2    Space press:
     → _try_auto_conversion_at_space()
     → current_lang = "en"
     → _extract_last_word_events() → word="ghbdtn", events=[g,h,b,d,t,n]
     → AutoDetector.should_convert("ghbdtn", "en"):
       a. "ghbdtn" in ENGLISH_WORDS? → Нет
       b. convert → "привет". "привет" in RUSSIAN_WORDS? → Да!
       → (True, "converted to Russian word 'привет'")
     → _do_auto_conversion_at_space(6, [...], "en_to_ru"):
       a. tap_key(BACKSPACE, 7)  — 6 символов + 1 пробел (уже попал в приложение)
       b. switch_layout(target=ru)
       c. replay_events([g,h,b,d,t,n]) → "привет" (в RU раскладке)
       d. tap_key(SPACE) → добавить пробел
       e. _last_auto_marker = {word:"ghbdtn", lang:"en", ...}
       f. context.reset(), state = IDLE
```

**Если потом Shift+Shift (отмена):**
```
_last_auto_marker != None → user_dict.add_correction("ghbdtn", "en") → weight -1
```

---

## Часть 2: Проблема PRIMARY буфера в Linux Mint (Cinnamon)

---

### Описание проблемы

**Нативное поведение Linux Mint (Cinnamon):**
- Пользователь выделяет текст → текст попадает в PRIMARY
- Пользователь кликает мышью (снимает выделение) → PRIMARY **НЕ очищается**
- Текст всё ещё можно вставить средней кнопкой мыши
- PRIMARY обновляется только при **новом** выделении

**Поведение с LSwitch:**
- Пользователь выделяет текст → PRIMARY = "текст"
- Пользователь кликает мышью → **PRIMARY очищается** ← БАГО
- Средняя кнопка мыши не вставляет ничего

---

### Анализ кода

#### 1. `_on_mouse_click` в app.py

```python
def _on_mouse_click(self, event):
    self._last_auto_marker = None
    self._selection_valid = False
    self._last_retype_events = []
    if self.selection is not None:
        try:
            info = self.selection.get_selection()        # ← ЧТЕНИЕ PRIMARY
            self._prev_sel_text = info.text
            self._prev_sel_owner_id = info.owner_id
        except Exception:
            pass
    self.state_manager.on_mouse_click()
```

**Вызов `get_selection()` при каждом клике мыши.**

#### 2. `X11SelectionAdapter.get_selection()`

```python
def get_selection(self) -> SelectionInfo:
    text = self._system.get_clipboard(selection="primary")     # xclip -o -selection primary
    owner_id = _get_selection_owner_id()                       # Xlib PRIMARY owner
    return SelectionInfo(text=text, owner_id=owner_id, timestamp=time.time())
```

**Вызывает `xclip -o -selection primary`.**

#### 3. `SubprocessSystemAdapter.get_clipboard()`

```python
def get_clipboard(self, selection: str = "primary") -> str:
    result = self.run_command(
        ["xclip", "-o", "-selection", selection], timeout=0.3
    )
    return result.stdout
```

Просто запускает `xclip -o -selection primary`.

#### 4. `SelectionMode.execute()`

```python
sel = self.selection.get_selection()    # чтение PRIMARY
...
self.selection.replace_selection(converted)  # запись через CLIPBOARD + Ctrl+V
```

#### 5. `replace_selection()`

```python
def replace_selection(self, new_text: str) -> bool:
    old_clip = self._system.get_clipboard(selection="clipboard")      # сохранить CLIPBOARD
    self._system.set_clipboard(new_text, selection="clipboard")       # записать в CLIPBOARD
    self._system.xdotool_key("ctrl+v")                                # Ctrl+V
    if old_clip is not None:
        self._system.set_clipboard(old_clip, selection="clipboard")   # восстановить CLIPBOARD
```

**ВАЖНО:** `replace_selection` НЕ трогает PRIMARY. Она работает через CLIPBOARD.

---

### Корневая причина проблемы

#### Проблема НЕ в `_on_mouse_click` напрямую

Метод `_on_mouse_click` только **читает** PRIMARY через `xclip -o`. Сам `xclip -o` не модифицирует PRIMARY.

Однако, `_get_selection_owner_id()` использует Xlib:

```python
def _get_selection_owner_id() -> int:
    try:
        from Xlib import display as xdisplay, Xatom, X
        d = xdisplay.Display()                         # открывает новое соединение!
        owner = d.get_selection_owner(Xatom.PRIMARY)
        owner_id = owner.id if owner and owner != X.NONE else 0
        d.close()                                      # закрывает соединение
        return owner_id
    except Exception:
        return 0
```

**Это открывает и закрывает X11 Display соединение при КАЖДОМ вызове.** Но это тоже только чтение.

#### Настоящая причина: `xclip -o` при пустом выделении

Проблема связана с поведением `xclip` в Cinnamon/X11:

1. В Cinnamon при клике мышью (отмена выделения) **owner PRIMARY не меняется** — предыдущее окно остаётся владельцем PRIMARY selection.
2. Но **LSwitch вызывает `xclip -o -selection primary` при каждом клике** (`_on_mouse_click` → `get_selection()`).
3. `xclip -o` выполняет **ConvertSelection** запрос к X серверу, что может побудить приложение-владелец PRIMARY обновить/сбросить содержимое selection.
4. Некоторые X11 приложения (особенно на GTK) при получении SelectionRequest после снятия выделения **отвечают пустой строкой или теряют владение PRIMARY**.

**Конкретный механизм:**

Когда `xclip -o -selection primary` выполняется **сразу после клика мыши** (который снял выделение):
- xclip отправляет `XConvertSelection` request для PRIMARY
- Приложение-владелец получает `SelectionRequest`
- Если выделение уже снято (пользователь только что кликнул), приложение **может ответить пустыми данными** или **отказаться от владения** (XSetSelectionOwner(None))
- Это "забирает" PRIMARY навсегда, пока не будет нового выделения

**Это race condition:** LSwitch вызывает `xclip -o` слишком рано после клика, когда приложение ещё обрабатывает событие снятия выделения.

#### Дополнительные места чтения PRIMARY

| Метод | Файл | Когда |
|-------|------|-------|
| `_on_mouse_click` | app.py | Каждый клик мыши |
| `_check_selection_changed` | app.py | При каждом Shift+Shift |
| `SelectionMode.execute` | modes.py | При конвертации выделения |
| `has_fresh_selection` | selection_adapter.py | Не вызывается из основного кода |

---

### Решение

#### Вариант 1 (рекомендуемый): Убрать чтение PRIMARY из `_on_mouse_click`

Снапшот PRIMARY при клике **не является обязательным**. Его цель — предотвратить ложные срабатывания, когда старое выделение из другого окна считается "новым" при Shift+Shift.

**Альтернатива:** вместо снапшота текста, запоминать только **факт клика** как маркер "неактуальности". При Shift+Shift проверять PRIMARY и сравнивать **только owner_id**, а сам `_check_selection_changed` будет запрашивать PRIMARY только лениво, при необходимости.

```python
# app.py — изменённый _on_mouse_click
def _on_mouse_click(self, event):
    self._last_auto_marker = None
    self._selection_valid = False
    self._last_retype_events = []
    # НЕ читаем PRIMARY здесь!
    # Маркируем, что был клик — _check_selection_changed учтёт это.
    self._mouse_clicked_since_last_check = True
    self.state_manager.on_mouse_click()
```

```python
# app.py — изменённый _check_selection_changed
def _check_selection_changed(self) -> bool:
    if self.selection is None:
        return False
    try:
        info = self.selection.get_selection()
        if not info.text:
            return False

        # Если был клик — обновить baseline, но не считать "свежим"
        if self._mouse_clicked_since_last_check:
            self._mouse_clicked_since_last_check = False
            self._prev_sel_text = info.text
            self._prev_sel_owner_id = info.owner_id
            # Не возвращаем True — клик не создаёт свежее выделение
            return False

        owner_changed = info.owner_id != self._prev_sel_owner_id and info.owner_id != 0
        text_changed = info.text != self._prev_sel_text
        if owner_changed or text_changed:
            self._prev_sel_text = info.text
            self._prev_sel_owner_id = info.owner_id
            self._selection_valid = True
            return True
    except Exception:
        pass
    return False
```

**Плюсы:**
- PRIMARY не читается при каждом клике мыши
- Нет race condition с приложением-владельцем
- `_check_selection_changed` вызывается только при Shift+Shift (редко)
- Нативное поведение PRIMARY не ломается

**Минусы:**
- Потенциально ложные срабатывания, если пользователь кликнет, а потом Shift+Shift — но это покрывается сравнением owner_id.

#### Вариант 2: Добавить задержку перед чтением PRIMARY

```python
def _on_mouse_click(self, event):
    self._last_auto_marker = None
    self._selection_valid = False
    self._last_retype_events = []
    # Отложить снапшот PRIMARY (не читать сразу после клика)
    self._pending_primary_snapshot = True
    self.state_manager.on_mouse_click()
```

И делать снапшот позже (при следующем key_press или с таймером). Но это добавляет сложность.

#### Вариант 3: Не использовать xclip, считывать через Xlib напрямую

Заменить `xclip -o -selection primary` на чтение через `python-xlib`:

```python
def get_selection_text_xlib(self) -> str:
    """Чтение PRIMARY selection через Xlib без ConvertSelection."""
    # Использовать XGetSelectionOwner для проверки, 
    # но НЕ запрашивать ConvertSelection
    pass
```

**Проблема:** чтение текста из PRIMARY **требует** ConvertSelection — нет другого способа в X11. Поэтому вариант 3 не избавляет от проблемы полностью.

### Рекомендация

**Вариант 1** — самый чистый и эффективный. Он устраняет корневую причину: ненужное чтение PRIMARY при **каждом** клике мыши.

Дополнительно можно оптимизировать `_get_selection_owner_id()`: вместо открытия нового Display* при каждом вызове, использовать кэшированное соединение из XKBAdapter:

```python
# Вместо:
def _get_selection_owner_id() -> int:
    d = xdisplay.Display()  # НОВОЕ соединение
    owner = d.get_selection_owner(Xatom.PRIMARY)
    d.close()               # закрытие
    return owner_id

# Лучше — передавать Display* из X11XKBAdapter или создать один раз:
class X11SelectionAdapter:
    def __init__(self, ...):
        self._xdisplay = xdisplay.Display()  # одно соединение на весь жизненный цикл

    def _get_owner_id(self) -> int:
        owner = self._xdisplay.get_selection_owner(Xatom.PRIMARY)
        ...
```

Это устранит накладные расходы на открытие/закрытие X11 соединений.

---

## Приложения

### A. Полная карта файлов проекта

| Файл | Назначение |
|------|------------|
| `lswitch/app.py` | Главный класс приложения, координатор |
| `lswitch/core/conversion_engine.py` | Выбор режима и запуск конвертации |
| `lswitch/core/modes.py` | RetypeMode + SelectionMode |
| `lswitch/core/state_manager.py` | Автомат состояний |
| `lswitch/core/states.py` | State enum + StateContext dataclass |
| `lswitch/core/transitions.py` | Таблица переходов |
| `lswitch/core/event_bus.py` | Pub/sub шина событий |
| `lswitch/core/event_manager.py` | evdev → typed EventBus events |
| `lswitch/core/events.py` | Типы событий |
| `lswitch/core/text_converter.py` | Чистая посимвольная конвертация |
| `lswitch/platform/selection_adapter.py` | X11 PRIMARY selection |
| `lswitch/platform/xkb_adapter.py` | XKB раскладки через libX11 |
| `lswitch/platform/system_adapter.py` | Интерфейс для subprocess |
| `lswitch/platform/subprocess_impl.py` | xclip, xdotool обёртки |
| `lswitch/input/device_manager.py` | evdev устройства + hot-plug |
| `lswitch/input/device_filter.py` | Фильтрация виртуальных устройств |
| `lswitch/input/virtual_keyboard.py` | UInput виртуальная клавиатура |
| `lswitch/input/key_mapper.py` | keycode → char |
| `lswitch/input/udev_monitor.py` | udev мониторинг hot-plug |
| `lswitch/intelligence/auto_detector.py` | Авто-определение языка |
| `lswitch/intelligence/dictionary_service.py` | Словари EN/RU |
| `lswitch/intelligence/ngram_analyzer.py` | Биграммы/триграммы |
| `lswitch/intelligence/user_dictionary.py` | Самообучение |
| `lswitch/intelligence/maps.py` | EN↔RU таблицы перекодировки |
| `lswitch/intelligence/persistence.py` | Атомарное сохранение JSON |

### B. Потоковая модель

```
Main thread:
  ├── QApplication.exec_() (если GUI)
  └── Qt event loop

evdev-loop thread (daemon):
  ├── DeviceManager.get_events(timeout=0.1)
  ├── EventManager.handle_raw_event()
  ├── EventBus.publish() → все обработчики синхронно
  ├── StateManager transitions
  └── ConversionEngine (retype/selection) — тоже в этом потоке

UdevMonitor thread (daemon):
  └── pyudev polling → on_added/on_removed callbacks
```

**Важно:** все EventBus handlers работают в evdev-loop потоке. ConversionEngine (включая xdotool_key, xclip) тоже вызывается из этого потока.
